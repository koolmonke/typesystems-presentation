# Системы типов
## 1. Основные концепты
Что такое система типов. Система типов - способ класификации сущностей в программе (выражений, переменных, значений и тд) по **типу** значенний которые они представляют для того чтобы предотвратить нежелаймое состояние программы. Для классификации сущностей используются типы данных. Большинство языков программирования имеют систему типов.
Допустим следующий код на C++
```cpp
int abc;
```
В C++, int это тип и переменная abc имеет тип int.


Современные ЯП предоставляют расширямую систему типов, которая позволяет программисту определять новые типы.
```cpp
class Zebra {  // Новый тип с названием "Zebra"
}
```

Проверка типов означает проверку и применение ограничений, связанных с системой типов. Различные действия, связанные с системой типов (определение типов, проверка типов), в совокупности называются типизацией.

## 2. Как используются типы
### Применение 1, определение валидных значений
Во-первых типы используются для определение значений которые могут принимать сущности.
Будучи типа int, переменная abc может прининять значение 42.
```cpp
abc = 42;
```

В тоже же время некоторые значения для abc невалидны.
```cpp
vector<int> v;
abc = v; // Ошибка тут
```

Мы не можем присвоить переменной типа int значение типа vector<int>. Компилятор C++ находит ошибку типов, что предотвращает успешную компиляцию программы.


### Применение 2, определение валидных операций
Типы так же позволяют определить какие операции валидны.
Поскольку abc имеет тип int, можно использовать бинарный оператор +.
```cpp
cout << abc + abc;
```

Некоторые операции невалидны для int. Например унарный оператор *. Компилятор выведет ошибку типов в следующий программе.
```cpp
cout << *abc;
```

Типы значениями которых можно манипулировать с достаточной легкостью и гипкостью, называются типами первого порядка.

Более формально, тип первого порядка, это такой тип, который:

* Новые значения которого могут быть созданы из уже существующих во время работы программы
* Значения могут быть переданы в функции и возращены из них
* Значения могут храниться в контейнирах

В некоторых ЯП, таких как Haskell, Scheme, JS, F# и Ocaml типы функций являются типами первого порядка. Такие ЯП имеют систему типов с функциями первого порядка.
    

### Применение 3, определение валидных операций
Третье применение является определение какую операцию применить из множества возможных.

```cpp
template <typename T, typename U, typename R>
R add(T a, U b)
{
    return a + b;
}
```

Мы можем вызвать add с двумя аргуменентами типа int, так и с двумя аргументами типа string. Операция применямая к переменным зависит от её типа. В случае строк это будет конкатинация, в случае чисел сложение.

JS так же использует бинарный оператор + как для численного сложения так и для конкатинации строк. Следующая функция на JS так же может быть вызвана как с 2 числами, так и с двумя строками.

```js
const add = (a, b) => {
    return a + b
}
```

Важным приложением этого является предоставление единого интерфейса для сущностьей разных типов. Подобный механизм называется полиморфизмом. Обе эти функции полиморфны.

## 3. Системы типов. Статические и динамические
### Определения
В статической системы типов, типы определяются и проверяются до начала выполняния программы. Обычно это делает компилятор. Ошибки типов определяются компилятором во время компиляции программы.

В динамической системе типов, типы определяются и проверяются во время выполнения программы. Типы отслеживаются с помощью закрепления за каждым значения определенного тега, определеяющего его тип. Ошибки типов определяются только после того как участок программы с ошибкой выполнится.

Независимо от типа системы типов, целью этой системы является предотвращение невалидных состояний программы.

### Ошибки во время компиляции и во время рантайма

В C++ и JS деление на строку является невалидной операцией

```cpp
cout << "Hello" << endl;
cout << 1 / "bye" << endl;  // Ошибка тут
```

Статическая проверка типов означает, что данных код просто не собирется.

Схоже, следующий код на JS произведет ошибку типов
```js
console.log("Hello")
console.log(1 / "bye") // Ошибка тут
```

Но из-за динамической типизации в JS, программа начнет свое выполенения и выводит Hello, после выводит NaN.

### Типизация значений и переменных и только значений

В статических системах типов, типы применяются как к переменным, так и к их значением.
```cpp
int x = 42;
```
Тут и переменная x и значение 42 имеет тип int.

В динамических системах только значения имеет тип.
Например в js
```js
let x = 42
x = "bye"
```
Тут переменная x не имеет тип, но значения 42 и "bye" имеют

Так же в динамических ЯП, контейнеры не хранят информацию о внутренних типах
```js
const mylist = [123, "hello", true]
```

## 4. Явная и неявная типизация

Когда мы явно указываем тип сущности - это называют явной типизация. Так например C++ и C#.
```cpp
double sqr47(double n) {
    double result = 4.7 * n * n;
    return result;
}
```

В этом примере мы указали типы для переменной (n double), (result double), и функции sqr47 (примающий double и возращаюший double)

Когда типы не указаны явно - это называют неявной типизацией.

```js
const sqr47 = n => {
    result = 4.7 * n * n
    return result
}
```

В этом примере нет анотаций типов.
В динамических ЯП, типизация по большей части неявная, поэтому очень часто хочеться совместить определения явной и динамической типизации, хотя эти 2 определения абсолютно разные.

```fsharp
let sqr47 n =
    let result = 4.7 * n * n
    result
```

Тут тоже нет анотаций типов. 
Тем не менее все индетифаеры: sqr47, n и result имеют конкретные типы. Так происходит поскольку компилятор F# производит выведение типов на основе того как сущности используются в коде, но это не означает что мы не можем указать все типы явно

```fsharp
let sqr47 (n: float): float =
    let result: float = 4.7 * n * n
    result
```

Не все типы всегда возможно вывести явно во время компиляции. Некоторый типы могут быть выведены только в общем виде

```fsharp
open System.Collections.Generic

let cached f =
    let cache = Dictionary()

    let g x =
        match cache.TryGetValue(x) with
        | true, v -> v
        | false, _ -> 
            let tmp = f x
            cache.Add(x, tmp)
            tmp
    
    g
```

Для данной функции будет автоматический выведен следующий тип

```fsharp
cached: f: ('a -> 'b) -> ('a -> 'b) when 'a: equality
```

Тут было определено что функция cached принимает в качестве своего едиственного аргумента функцию f, которая принимает в качестве своего едиственного аргумента значения типа 'a и возвращает значение типа 'b, после возвращает функцию того же типа что и f 

В C++ так же возможно выведение типов с помощью ключевого слова auto

```cpp
auto sqr47(double n) {
    auto result = 4.7 * n * n;
    return result;
}
```

### Явное и неявное приведение типов

Явное приведение типа принимает в качество одного из параметров значение одного типа и в качестве второго параметра другой тип и возрашает примерное ее представление в новом типе.

Неявное приведение типов это когда значения одного автоматический приводятся в значения другого типа без необходимости каких-либо дополнительных действий от программиста.

Например C++ имеет неявное приведение int в double

```cpp
int n = 32;
auto z = sqr47(n);
```
sqr47 принимает в качестве своего единственного параметра double, а n будучи изначально int неявно приводится в double, после чего передается в sqr47.

Так же в C++ возможно явное приведение типов

```cpp
int n = 32;
auto z = sqr47(static_cast<double>(n));
```

В F# нет неявного приведения типов. Поэтому данный код не скомпилируется ввиду ошибки типов
```fsharp
let n = 32
let z = sqr47 n; // Тут ошибка: n это int когда ожидался float
```

Явное приведение типов исправит ошибку

```fsharp
let n = 32
let z = sqr47 (float n)
```



### Структурная и номинальная типизация


#### Номинальная типизация
Допустим следующие 2 типа

```cpp
struct A {
    int h;
    int m;
};

struct B {
    int h;
    int m;
};
```

Должны ли типы A и B считаться одинаковыми при проверки типов. Например при вызове

```cpp
void g(A x);
```
Должна ли функция g работать верно и для типа B?

Может показаться что нет никакого смысла различать типы A и B, поскольку все операции для типа A валидны и для типа B, но в тоже время, программист решил выделить 2 разных типа. Возможно тип А представляет собой структуру из часов и минут, а тип B из попаданий и промахов в игре. 
Разделение типов с одинаковой структурой, но с разным названием называется номинальной (от латинского nomus имя) типизацией.

#### Структурная типизация

Структурная типизация это такая типизация при которой возможна взаимозамена типов с одинаковой структурой. Например, типы A и B взаимозаменяемы. Самый вольный вариант структурной типизации позволяет передавать аргумент функции при условии, что каждая операция, которую фактически использует функция, определена для аргумента. Подобная типизация называется утиной.


В C++ шаблоны используют для проверки утиную типизацию. 
```cpp
template <typename T>
void g(T x) {
    cout << x.h << " " << x.m << endl;
}
```
Так же в функции add написаной ранее на JS и C++ используется утиная типизация

```cpp
template <typename T, typename U, typename R>
R add(T a, U b)
{
    return a + b;
}
```


```js
const add = (a, b) => {
    return a + b
}
```